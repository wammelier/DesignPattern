#designPattern에 대해서

# 상속에 대한 고찰...

상속은 가장 좋은 해결방안은 아니다. 규격이 계속 바뀔 때마다 전에 추가했던 메소드를 일일이 살펴봐야 하고, 상황에 따라 오버라이드해야 할 수도 있으니깐..
예를들어 subClass에 오버라이드된 메소드가 조금이라도 바뀌면 해당하는 subClass는 모두 코드를 고쳐야하기 때문에...
서브클래스마다 행동이 바뀔수 있는데도 모든 서브 클래스에서 한 행동을 사용하도록 하는 것은 옳바르지 않다...

# 변화하는 부분과 그렇지 않은 부분 구분하기
오리를 예를 들어볼때 첫번째는 하늘을 나는것과 두번째로는 꽥꽥거리는 소리 와 관련된것을 분류한다. 각 클래스 집합에는 각각의 행동을 구현한 것을 전부 집어넣는다.
예를들어 꽥꽥거리는 것을 구현하는 클래스를 하나 만들고, 삑삑거리는 것을 구현하는 클래스를 하나 만들고, 아무 소리도 내지 않는 것을 구현하는 클래스를 하나 만든는 식이다.

Duck class 에서 fly(), quack()는 오리마다 달라지는 부분이다! 이러한 행동을 Duck클래스로부터 갈라내기 위해서 그 두 메소드를 모두 Duck 클래스로부터 끄집어내서 각 행동을
나타낼 클래스 집합을 새로 만들도록 한다.

각 행동은 인터페이스(ex: FlyBehavior, QuackBehavior)로 표현하고 행동을 구현할 때 이런 인터페이스를 구현한다.

인터페이스에 맞춰서 프로그래밍한다 는 것은 사실 상위 형식에 맞춰서 프로그래밍한다 는 것을 뜻한다.


<h4>인터페이스에 맞춰서 프로그래밍한다는 것은 사실 상위 형식에 맞춰 프로그래밍한다는 것이다.</h4>
실제 실행시에 쓰이는 객체가 코드에 의해서 고정되지 않도록, 어떤 상위 형식에 맞춰서 프로그래밍함으로써 다형성을 활용해야 한다는 것이다.
그리고 상위 형식에 맞춰서 프로그래밍하라는 원칙은 변수를 선언할 때는 보통 추상 클래스나 인터페이스 같은 상위 형식으로 선언해야 한다. 객체를 변수에 대입할 때 상위 형식을 구체적으로 구현한 형식이라면
어떤 객체든 집어넣을 수 있기 때문이다. 그래서 실제 객체의 형식은 몰라도 된다.

방식 1 ) Dog d = new Dog();
        dog.bark();
        이방법은 변수 'd'를 Dog 형식(Animal을 확장한 구상 클래스)으로 선언하면 어떤 구체적인 구현에 맞춰서 코딩을 해야만 한다.

방식 2 ) Animal animal = new Dog();
        animal.makeSound();
        이방법은 Dog라는 걸 알고 있긴 하지만 다형성을 활용하여 Animal에 대한 레퍼런스를 써도 된다.
        
방식 3 ) a = getAnimal();
        a.makeSound();
        이방법이 제일 바람직하다. 상위 형식의 인스턴스를 만드는 과정을(new Dog() 같은 식으로) 직접 코드를 만드는 대신 구체적으로 구현된 객체를 실행시에 대입하는 것이다.
        Animal의 하위 형식 가운데 어떤 형식인지는 모르지만 단지 makeSound()에 대해 올바른 반응을 할 수만 있으면 된다.
        

추상화나 상속, 다형성 같은 개념을 알고 있다고 해서 무조건 훌륭한 객체지향 디자이너가 될수없다. 관리가
용이하게 상황에 맞게 변경할 수 있는 유연한 디자인을 만드는 것에 대해 생각해 봐야 한다.

# 옵저버 패턴에 대해서....
뭔가 중요한 일이 일어났을 때 객체들한테 새소식을 알려줄 수 있는 패턴이 있다. 객체 쪽에서는 정보를 받을지 여부를 실행중에 결정할 수 있다. 옵저버 패턴은 JDK에서 가장 많이 쓰이는
패턴 가운데 하나다. 일대다 느슨한 결합에 대해 장점을 가지고 있다.

출판사 + 구독자 = 옵저버 패턴
신문 구독 메커니즘만 제대로 이해할 수 있다면 옵저버 패턴을 쉽게 이해 할 수 있다.
출판사를 주제(subject), 구독자를 옵저버(observer)라고 부른는 것만 외우자.
        