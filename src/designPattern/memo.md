#designPattern에 대해서

# 상속에 대한 고찰...

상속은 가장 좋은 해결방안은 아니다. 규격이 계속 바뀔 때마다 전에 추가했던 메소드를 일일이 살펴봐야 하고, 상황에 따라 오버라이드해야 할 수도 있으니깐..
예를들어 subClass에 오버라이드된 메소드가 조금이라도 바뀌면 해당하는 subClass는 모두 코드를 고쳐야하기 때문에...
서브클래스마다 행동이 바뀔수 있는데도 모든 서브 클래스에서 한 행동을 사용하도록 하는 것은 옳바르지 않다...

# 변화하는 부분과 그렇지 않은 부분 구분하기
오리를 예를 들어볼때 첫번째는 하늘을 나는것과 두번째로는 꽥꽥거리는 소리 와 관련된것을 분류한다. 각 클래스 집합에는 각각의 행동을 구현한 것을 전부 집어넣는다.
예를들어 꽥꽥거리는 것을 구현하는 클래스를 하나 만들고, 삑삑거리는 것을 구현하는 클래스를 하나 만들고, 아무 소리도 내지 않는 것을 구현하는 클래스를 하나 만든는 식이다.

Duck class 에서 fly(), quack()는 오리마다 달라지는 부분이다! 이러한 행동을 Duck클래스로부터 갈라내기 위해서 그 두 메소드를 모두 Duck 클래스로부터 끄집어내서 각 행동을
나타낼 클래스 집합을 새로 만들도록 한다.

각 행동은 인터페이스(ex: FlyBehavior, QuackBehavior)로 표현하고 행동을 구현할 때 이런 인터페이스를 구현한다.

인터페이스에 맞춰서 프로그래밍한다 는 것은 사실 상위 형식에 맞춰서 프로그래밍한다 는 것을 뜻한다.


<h4>인터페이스에 맞춰서 프로그래밍한다는 것은 사실 상위 형식에 맞춰 프로그래밍한다는 것이다.</h4>
실제 실행시에 쓰이는 객체가 코드에 의해서 고정되지 않도록, 어떤 상위 형식에 맞춰서 프로그래밍함으로써 다형성을 활용해야 한다는 것이다.
그리고 상위 형식에 맞춰서 프로그래밍하라는 원칙은 변수를 선언할 때는 보통 추상 클래스나 인터페이스 같은 상위 형식으로 선언해야 한다. 객체를 변수에 대입할 때 상위 형식을 구체적으로 구현한 형식이라면
어떤 객체든 집어넣을 수 있기 때문이다. 그래서 실제 객체의 형식은 몰라도 된다.

방식 1 ) Dog d = new Dog();
        dog.bark();
        이방법은 변수 'd'를 Dog 형식(Animal을 확장한 구상 클래스)으로 선언하면 어떤 구체적인 구현에 맞춰서 코딩을 해야만 한다.

방식 2 ) Animal animal = new Dog();
        animal.makeSound();
        이방법은 Dog라는 걸 알고 있긴 하지만 다형성을 활용하여 Animal에 대한 레퍼런스를 써도 된다.
        
방식 3 ) a = getAnimal();
        a.makeSound();
        이방법이 제일 바람직하다. 상위 형식의 인스턴스를 만드는 과정을(new Dog() 같은 식으로) 직접 코드를 만드는 대신 구체적으로 구현된 객체를 실행시에 대입하는 것이다.
        Animal의 하위 형식 가운데 어떤 형식인지는 모르지만 단지 makeSound()에 대해 올바른 반응을 할 수만 있으면 된다.
        

추상화나 상속, 다형성 같은 개념을 알고 있다고 해서 무조건 훌륭한 객체지향 디자이너가 될수없다. 관리가
용이하게 상황에 맞게 변경할 수 있는 유연한 디자인을 만드는 것에 대해 생각해 봐야 한다.

# 옵저버 패턴에 대해서....
뭔가 중요한 일이 일어났을 때 객체들한테 새소식을 알려줄 수 있는 패턴이 있다. 객체 쪽에서는 정보를 받을지 여부를 실행중에 결정할 수 있다. 옵저버 패턴은 JDK에서 가장 많이 쓰이는
패턴 가운데 하나다. 일대다 느슨한 결합에 대해 장점을 가지고 있다.

출판사 + 구독자 = 옵저버 패턴
신문 구독 메커니즘만 제대로 이해할 수 있다면 옵저버 패턴을 쉽게 이해 할 수 있다.
출판사를 주제(subject), 구독자를 옵저버(observer)라고 부른는 것만 외우자.
        

옵저버패턴에서는 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다.
한 객체의 상태가 변경되면 그 책체에 의존하는 모든 객체에 연락이 간다.

주제 역할을 하는 구상 클래스에서는 항상 subject 인터페이스를 구현해야 한다. 주제 클래스에서는 등록 및 해지를 위한 메소드 위에 상태가 바뀔 때마다 모든 옵저버들에게
연락을 하기 위한 notifyObservers()메소드도 구현해야한다.

옵저버가 될 가능성이 있는 객체에서는 반드시 Observer 인터페에이스를 구현해야한다. 이 인터페이스에는 주제의 상태가 바뀌었을때 호출되는 update() 메소드 밖에 없다.

Observer 인터페이스만 구현한다면 무엇이든 옵저버 클래스가 될 수 있다. 각 옵저버는 특정 주제 객체에 등록을 해서 연락을  받을 수 있다.

데이터의 주인은 주제(Subject)이다. 옵저버는 데이터가 변경되었을 때 주제에서 갱신해 주기를 기다리는 입장이기 때문에 의존성을 가진다고 할 수 있다. 이런 방법을 사용하면 여러
객체에서 동일한 데이터를 제어하도록 하는 것에 비해 더 깔끔한 객체지향 디자인을 만들 수 있다.

두 객체가 느슨하게 결합되어 있다는 것은, 그 둘이 상호작용을 하긴 하지만 서로에 대해 서로 잘 모른다는 것을 의미한다.
옵저버 패턴에서는 주제와 옵저버가 느슨하게 결합되어 있는 객체 디자인을 제공한다.
1. 주제가 옵저버에 대해서 아는 것은 옵저버가 특정 인터페이스를 구현한다는 것 뿐이다.
2. 옵저버는 언제든지 새로 추가할 수 있다.
3. 새로운 형식의 옵저버를 추가하려고 할 때도 주제를 전혀 변경할 필요가 없다.
4. 주제와 옵저버는 서로 독립적으로 재사용할 수 있다.
5. 주제나 옵저버가 바뀌더라도 서로한테 영향을 미치지 않는다.

96페이지 부터



